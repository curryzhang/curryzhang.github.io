(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{221:function(n,e,t){"use strict";t.r(e);var a=t(2),s=Object(a.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"c-重温—泛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#c-重温—泛型","aria-hidden":"true"}},[n._v("#")]),n._v(" C#重温—泛型")]),n._v(" "),t("h2",{attrs:{id:"泛型定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型定义","aria-hidden":"true"}},[n._v("#")]),n._v(" 泛型定义")]),n._v(" "),t("p",[n._v("泛型就是泛指的类型。这是在.NET Framework 2.0出现的语法。")]),n._v(" "),t("p",[t("strong",[n._v("泛型的好处：")])]),n._v(" "),t("ul",[t("li",[n._v("类型的安全性")]),n._v(" "),t("li",[n._v("代码的可重用性")]),n._v(" "),t("li",[n._v("提升效率（避免了不必要的装箱拆箱）。")])]),n._v(" "),t("p",[n._v("下面我分别来说明这三点。")]),n._v(" "),t("ol",[t("li",[n._v("泛型会约束变量的类型。比如ArryList可以添加任意类型的值，而List"),t("int",[n._v("只能添加int类型的值")])],1)]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('ArrayList list = new ArrayList();\nlist.Add("hello");\nlist.Add(1111);\n\n List<int> list = new List<int>();\nlist.Add(11);\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("定义了一个泛型类Generic来提高代码可重用性，在指定的时候是泛指类型，在使用的时候就需要特定类型。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('static void Main(string[] args)\n{\n  Generic<string> gs1 = new Generic<string>();\n  gs1.Name = "hello world";\n  Console.WriteLine(gs1.Name);\n\n  Generic<int> gs2 = new Generic<int>();\n  gs2.Name = 111;\n  Console.WriteLine(gs2.Name);\n\n  Generic<Task> gsTask = new Generic<Task>();\n  gsTask.Name = Task.Run(() => {\n    Console.WriteLine("这是一个Task");\n  });\n}\n\npublic class Generic<T>\n{\n  public T Name=default(T);\n}\n')])])]),t("ol",{attrs:{start:"3"}},[t("li",[n._v("泛型会固定类型，在使用的时候就知道是什么类型了，避免了不必要的类型转换。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('object a = 18;\nint b = (int)a;\n//泛型\nint c = GetValue<int>(19);\nstring b = GetValue<string>("hello");\n public static T GetValue<T>(T a)\n{\n  return a;\n}\n')])])]),t("h3",{attrs:{id:"泛型约束"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型约束","aria-hidden":"true"}},[n._v("#")]),n._v(" 泛型约束")]),n._v(" "),t("p",[n._v("话不多少，先看代码")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('static void Main(string[] args)\n{\n    Generic<Fanxing> g = newGeneric<Fanxing>();\n    Fanxing fx = new Fanxing();\n    fx.Name = "Jack";\n    g.Name = fx;\n    Console.WriteLine(g.Name.Name);\n    \n    Generic<Base> gsBase = newGeneric<Base>();\n    Base b = new Base();\n    b.Name = "Curry";\n    gsBase.Name = b;\n    Console.WriteLine(gsBase.Name.Name);\n    \n    Console.ReadKey();\n}\n\npublic class Generic<T> where T :Base\n{\n    public T Name=default(T);\n}\npublic class Base\n{\n    public string Name { get; set; }\n}\npublic class Fanxing:Base\n{\n    public new string Name { get; set; }\n}\n')])])]),t("p",[n._v("泛型默认会有一个约束，当我们不显示的声明时，这个约束不存在。但当我们显示的声明的时候，这个约束就会执行。")]),n._v(" "),t("p",[n._v("从代码中可以看出where T : Base就是这个特别的约束。这个约束限制了泛型的类型，要求我们Generic类的指定类型T必须是Base或者继承Base类的类型。")]),n._v(" "),t("table",[t("thead",[t("tr",[t("th",[n._v("约束")]),n._v(" "),t("th",[n._v("说明")])])]),n._v(" "),t("tbody",[t("tr",[t("td",[n._v("T：struct")]),n._v(" "),t("td",[n._v("类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。")])]),n._v(" "),t("tr",[t("td",[n._v("T：class")]),n._v(" "),t("td",[n._v("类型参数必须是引用类型，包括任何类、接口、委托或数组类型。")])]),n._v(" "),t("tr",[t("td",[n._v("T：new()")]),n._v(" "),t("td",[n._v("类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定。")])]),n._v(" "),t("tr",[t("td",[n._v("T：<基类名>")]),n._v(" "),t("td",[n._v("类型参数必须是指定的基类或派生自指定的基类。")])]),n._v(" "),t("tr",[t("td",[n._v("T：<接口名称>")]),n._v(" "),t("td",[n._v("类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。")])]),n._v(" "),t("tr",[t("td",[n._v("T：U")]),n._v(" "),t("td",[n._v("为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。这称为裸类型约束。")])])])]),n._v(" "),t("h3",{attrs:{id:"泛型函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型函数","aria-hidden":"true"}},[n._v("#")]),n._v(" 泛型函数")]),n._v(" "),t("p",[n._v("泛型不仅能作用在类上，也可单独用在方法上，它可以根据方法参数的类型自动适应各种参数，这样的方法叫泛型方法。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('static void Main(string[] args)\n{\n    Person p = new Person();\n    p.GetInfo<int>(11);\n    p.GetInfo<string>("11");\n    Console.ReadKey();\n}\n\npublic class Person\n{\n    public void GetInfo<T>(T obj)\n    {\n        if (obj.GetType()== typeof(int))\n        {\n            Console.WriteLine("这是一个int类型:"+ obj.GetType());\n        }else if (obj.GetType() == typeof(string))\n        {\n            Console.WriteLine("这是一个string类型");\n        }\n    }\n}\n')])])]),t("h3",{attrs:{id:"泛型委托action和func"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型委托action和func","aria-hidden":"true"}},[n._v("#")]),n._v(" 泛型委托Action和Func")]),n._v(" "),t("ol",[t("li",[n._v("Action是无返回值的泛型委托,Action至少0个参数，至多16个参数，无返回值。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('Action<string, int> action = (a, b) => Console.WriteLine(a+b); \naction("hello", 18);\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("Func是有返回值的泛型委托，Func至少0个参数，至多16个参数，根据返回值泛型返回。必须有返回值，不可void")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Func<int, int, int> add= (x, y) => x + y;\nint result = add(1, 2);\n")])])]),t("p",[n._v("参考："),t("a",{attrs:{href:"https://www.cnblogs.com/kiba/p/9321530.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("C#语法——泛型的多种应用"),t("OutboundLink")],1)])])},[],!1,null,null,null);e.default=s.exports}}]);